# AdLotto â€“ The Zero-Loss Attention Data Marketplace

> **Track:** Data Economy / Marketplaces
> **Stack:** Sui Move + Walrus (Storage) + Seal (Privacy)

AdLotto is a **decentralized data marketplace** that prices user attention using staking yield.

  - **Advertisers** stake SUI to upload **encrypted ad blobs** (stored on Walrus) to the marketplace.
  - **The Protocol** uses a VRF-driven lottery to select high-value ads for public decryption ("The Hero Spot").
  - **Viewers** act as data producers, submitting cryptographic **Proofs of Attention** (via Seal decryption signatures) to earn the yield generated by the stakes.

-----

## ðŸ§  Judges TL;DR

  - **The Innovation:** We turned "Ad Spend" into **Total Value Locked (TVL)** and "Impressions" into **Cryptographic Proofs**.
  - **Why itâ€™s a Data Marketplace:**
      - It creates a transparent exchange where **Liquidity** (Advertisers) buys **Verified Attention Data** (Users).
      - Unlike Web2, the "price" of attention is determined by the **yield curve**, not an opaque auction.
  - **Best Tech Implementation:**
      - **Walrus:** Stores high-res ad creatives as decentralized blobs (`blob_id`).
      - **Seal:** Encrypts ads client-side. The Move contract controls the `seal_approve` logic, allowing decryption *only* upon "Winner Selection" or "Proof of Attention" verification.
      - **Sui VRF:** Ensures the selection of the "Hero Ad" is tamper-proof and auditable.

-----

## Architecture: The "Trust Engine"

The system is composed of three layers:

1.  **Storage Layer (Walrus):** Holds the encrypted raw assets (images/videos).
2.  **Privacy Layer (Seal):** Manages Identity-Based Encryption (IBE) keys.
3.  **Settlement Layer (Sui Move):** Manages stakes, verifies proofs, and distributes yield.

### High-Level Flow

1.  **Submission:** Advertiser uploads encrypted blob to Walrus -\> Calls `submit_sealed_ad` on-chain with the `blob_id` + stake.
2.  **The Lottery (Epoch):**
      * A **Keeper Bot** triggers the end of an epoch.
      * **Sui VRF** selects a winner based on stake weight.
      * The contract flags the ad as `is_unsealed = true`.
3.  **The Exchange (Proof of Attention):**
      * **Public Reveal:** The Hero Billboard decrypts the winning ad for everyone.
      * **Private Exchange:** Users browse *other* active ads. To view them, they perform a **Seal Decryption**. This generates a signature ("Proof").
      * **Payout:** The user submits this proof to the `Verification` module to claim their share of the staking yield.

-----

## Smart Contracts (`/sources`)

### 1\. `ad_entry.move` (The Asset Registry)

Manages the lifecycle of the "Ad Data Asset."

  * **Struct `Advertisement`:**
      * `sealed_blob_id`: The Walrus ID pointing to the encrypted file.
      * `encryption_id`: The Seal policy ID used for decryption checks.
      * `staking_position`: The DeFi position backing this ad.
  * **Key Function `submit_sealed_ad`:**
      * Takes `Coin<MOCK_SUI>` and a `blob_id`.
      * Mints a `StakingPosition` and locks it inside the `Advertisement` object.
      * Emits `AdSubmitted` event for the Indexer.

### 2\. `lottery.move` (The Matching Engine)

Handles the randomization and selection of the "Hero" ad.

  * **Key Function `pick_winner`:**
      * Uses `sui::random::Random` to select an index from the `active_ads` vector.
      * Weighted probability is based on the `principal` amount of the staking position.
  * **Key Function `finalize_epoch`:**
      * Updates the global `LotteryConfig`.
      * Changes the winning ad's state to `is_unsealed`.
      * Triggers the "Yield Harvest" event.

### 3\. `verification.move` (The Data Verification)

*New module for Data Economy Track.*
Verifies that a user has performed the necessary "Work" (Attention) to earn rewards.

  * **Key Function `verify_proof_of_attention`:**
      * Accepts a cryptographic signature derived from the Seal decryption process.
      * Verifies the user authorized the decryption of specific `blob_id`.
      * If valid, calls `treasury::payout_reward(user_address)`.

### 4\. `mock_yield_protocol.move` & `treasury.move`

Simulates the DeFi yield generation (Liquid Staking) to power the economy on Testnet.

  * **Yield Split:** 10% Protocol Fee / 40% Advertiser / 50% Viewer Rewards.

-----

## Keeper Bot (`/scripts`)

The heartbeat of the marketplace. The bot ensures the "Data Epochs" keep rolling.

  * **Path:** `scripts/start.ts`
  * **Responsibilities:**
    1.  **Monitor Time:** Checks if `current_timestamp > last_draw_time + epoch_duration`.
    2.  **Execute VRF:** Calls `lottery::pick_winner`.
    3.  **Distribute Rewards:** Triggers the `payout` cycle for the previous epoch's attention providers.
    4.  **Logging:** Pushes structured logs for the frontend to display "Next Draw" timers.

-----

## Getting Started

### Prerequisites

  * Sui CLI (Testnet)
  * Node.js v20+
  * Walrus CLI (optional, for manual blob management)

### 1\. Build & Test

```bash
npm install
npm run build
npm run test
```

### 2\. Deploy to Testnet

```bash
# Deploys the package and saves object IDs to .deployment-config.json
npm run deploy
```

### 3\. Run the Keeper Bot

To start the lottery cycles and enable the "Winner Reveal" mechanics:

```bash
# Uses the private key from .env to sign keeper transactions
npm run start
```

-----

## Data Surface for Judges (Hackathon Integration)

AdLotto produces a rich, open dataset on-chain that fits the **Data Economy** theme. You can query:

1.  **The Ad Ledger:** Query `AdRegistry` to get a list of all `sealed_blob_id`s (Content) and their `staking_balance` (Valuation).
2.  **The Attention Ledger:** Query `VerificationSession` to see a history of which addresses submitted proofs for which ads.
3.  **The Yield Curve:** Analyze `EpochFinalized` events to calculate the "Cost of Attention" over time (APY vs Views).
